'''Additional module to frequency.py for excel output.'''

import os
import sqlite3
from string import ascii_lowercase
import xlsxwriter


class ExcelWriter:
    '''Convert generated .db data to excel view.

    All mandatory functions are called all at once by treat().
    Additional functions – sheet_en_symb_bigrams(), sheet_ru_symb_bigrams() and sheet_yo_words()
        are called individually.

    Input:
        name    – name of generated by frequency.py analysis;
        limits  – list – max number of elements to be added to the sheet (0 – unlimited))
                – [symbols, symbol bigrams top, words top, word bigrams top]
                – default values – [0, 0, 0, 0];
        min_quantity – list – min number of entries for each element to take it into account)
                – [[same as on 'limits'], +symbol bigrams table]
                – default values – [1, 1, 1, 1, 1].
                – (symbs, symb bigrams top, words top, word bigrams top, !symbol bigrams table!).
    '''

    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, 'instance'):
            cls.instance = super(ExcelWriter, cls).__new__(cls, *args, **kwargs)
        return cls.instance

    def __init__(self, name, limits=[0, 0, 0, 0], min_quantity=[1, 1, 1, 1, 1]):
        self.workbook = xlsxwriter.Workbook(os.path.join(os.getcwd(), name, 'result.xlsx'))
        self.db = sqlite3.connect(os.path.join(os.getcwd(), name, 'result.db'))
        self.cursor = self.db.cursor()
        self.limits = limits + [0] * (4 - len(limits))
        self.min_quantity = min_quantity + [1] * (5 - len(min_quantity))

        self.pos = lambda x: self.cursor.execite(f'SELECT AVG(position) FROM {x};').fetchone()[0]
        self.count = lambda x: self.cursor.execute(f'SELECT COUNT(*) FROM {x};').fetchone()[0]
        self.sum = lambda x: self.cursor.execute(f'SELECT SUM(quantity) FROM {x};').fetchone()[0]

    def treat(self):
        '''Create main sheets all at once.'''
        print('Start of writing to .xlsx')
        self.sheet_stats()
        print('... stats sheet was written')
        self.sheet_symbols()
        print('... symbols sheet was written')
        self.sheet_symbol_bigrams_top()
        print('... top symbol bigrams sheet was written')
        self.sheet_all_symb_bigrams()
        print('... symbol bigrams table sheet was written')
        self.sheet_top_words()
        print('... top words sheet was written')
        self.sheet_word_bigrams_top()
        print('... top word bigrams sheet was written')
        print('End of writing main sheets.')
        print(
            'You can call additional functions for more sheets (e.g. "sheet_en_symb_bigrams()", \
            "sheet_ru_symb_bigrams()" or "yo_words()")'
        )

    def sheet_stats(self):
        '''Create main statistic of analysis. Is called from main "treat()".'''
        stats = self.workbook.add_worksheet('Stats')
        stats.write(0, 1, 'Total')
        stats.write(0, 2, 'Count')

        stats.write(1, 0, 'Symbols')
        stats.write(2, 0, 'Symbol bigrams')
        stats.write(3, 0, 'Words')
        stats.write(4, 0, 'Word bigrams')

        stats.write(1, 1, self.count('symbols'))
        stats.write(2, 1, self.count('symbol_bigrams'))
        stats.write(3, 1, self.count('words'))
        stats.write(4, 1, self.count('word_bigrams'))
        stats.write(1, 2, self.sum('symbols'))
        stats.write(2, 2, self.sum('symbol_bigrams'))
        stats.write(3, 2, self.sum('words'))
        stats.write(4, 2, self.sum('word_bigrams'))

    def sheet_symbols(self):
        '''Create top-list of all analyzed symbols by quantity. Is called from main "treat()".'''
        position = False
        all_sum = self.sum('symbols')
        symbols = self.workbook.add_worksheet('Symbols')
        symbols.write(0, 0, 'Symbol')
        symbols.write(0, 1, 'Quantity')
        symbols.write(0, 2, '% from all')
        symbols.write(0, 3, 'As first')
        symbols.write(0, 4, 'As last')
        if self.pos('symbols') != 1:
            position = True
            symbols.write(0, 5, 'Avg. position')

        self.cursor.execute(
            f'''
            SELECT *
            FROM symbols
            WHERE quantity >= {self.min_quantity[0]}
            ORDER BY quantity DESC, ord ASC
            {f'LIMIT {self.limits[0]}' if self.limits[0] else ''};
            '''
        )
        for row, symb in enumerate(self.cursor.fetchall(), 1):
            symbols.write(row, 0, chr(symb[0]))
            symbols.write(row, 1, symb[1])
            symbols.write(row, 2, symb[1] / all_sum)
            symbols.write(row, 3, symb[2])
            symbols.write(row, 4, symb[3])
            if position:
                symbols.write(row, 5, symb[4])

    def sheet_symbol_bigrams_top(self):
        '''Create top-list of symbol bigrams by quantity. Is called from main "treat()".'''
        position = False
        all_sum = self.sum('symbol_bigrams')
        symbol_bigrams_top = self.workbook.add_worksheet('Symbol bigrams top')
        symbol_bigrams_top.write(0, 0, 'First symb')
        symbol_bigrams_top.write(0, 1, 'Second symb')
        symbol_bigrams_top.write(0, 2, 'Quantity')
        symbol_bigrams_top.write(0, 3, '% from all')
        if self.pos('symbol_bigrams'):
            position = True
            symbol_bigrams_top.write(0, 4, 'Avg. position')

        self.cursor.execute(
            f'''
            SELECT *
            FROM symbol_bigrams
            WHERE quantity >= {self.min_quantity[1]}
            ORDER BY quantity DESC, first_symb ASC, second_symb ASC
            {f'LIMIT {self.limits[1]}' if self.limits[1] else ''};
            '''
        )
        for row, bigr in enumerate(self.cursor.fetchall(), 1):
            symbol_bigrams_top.write(row, 0, chr(bigr[0]))
            symbol_bigrams_top.write(row, 1, chr(bigr[1]))
            symbol_bigrams_top.write(row, 2, bigr[2])
            symbol_bigrams_top.write(row, 3, bigr[2] / all_sum)
            if position:
                symbol_bigrams_top.write(row, 4, bigr[3])

    def sheet_all_symb_bigrams(self):
        '''Create 2D bigrams table for all analyzed symbols. Is called from main "treat()".'''
        all_symb_bigrams = self.workbook.add_worksheet('All symb bigrams')
        self.cursor.execute(
            f'''
            SELECT *
            FROM symbol_bigrams
            WHERE quantity >= {self.min_quantity[4]}
            ORDER BY first_symb ASC, second_symb ASC;
            '''
        )
        locations: dict = {}
        for pair in self.cursor.fetchall():
            for elem_num in [0, 1]:
                if pair[elem_num] not in locations:
                    locations[pair[elem_num]] = len(locations) + 1
                    all_symb_bigrams.write(0, locations[pair[elem_num]], chr(pair[elem_num]))
                    all_symb_bigrams.write(locations[pair[elem_num]], 0, chr(pair[elem_num]))
            all_symb_bigrams.write(locations[pair[0]], locations[pair[1]], pair[2])

    def sheet_top_words(self):
        '''Create top-list of words by quantity. Is called from main "treat()".'''
        position = False
        all_sum = self.sum('words')
        top_words = self.workbook.add_worksheet('Top words')
        top_words.write(0, 0, 'Word')
        top_words.write(0, 1, 'Quantity')
        top_words.write(0, 2, '% from all')
        top_words.write(0, 3, 'As first')
        top_words.write(0, 4, 'As last')
        test_pos = self.pos('words')
        if test_pos and test_pos != 1:
            position = True
            top_words.write(0, 5, 'Avg. position')

        self.cursor.execute(
            f'''
            SELECT *
            FROM words
            WHERE quantity >= {self.min_quantity[2]}
            ORDER BY quantity DESC, word ASC
            {f'LIMIT {self.limits[2]}' if self.limits[2] else ''};
            '''
        )
        for row, word in enumerate(self.cursor.fetchall(), 1):
            top_words.write(row, 0, word[0])
            top_words.write(row, 1, word[1])
            top_words.write(row, 2, word[1] / all_sum)
            top_words.write(row, 3, word[2])
            top_words.write(row, 4, word[3])
            if position:
                top_words.write(row, 5, self.cursor.fetchone()[4])

    def sheet_word_bigrams_top(self):
        '''Create top-list of word bigrams by quantity. Is called from main "treat()".'''
        position = False
        all_sum = self.sum('word_bigrams')
        word_bigrams_top = self.workbook.add_worksheet('Word bigrams top')
        word_bigrams_top.write(0, 0, 'First word')
        word_bigrams_top.write(0, 1, 'Second word')
        word_bigrams_top.write(0, 2, 'Quantity')
        word_bigrams_top.write(0, 3, '% from all')
        if self.pos('word_bigrams'):
            position = True
            word_bigrams_top.write(0, 4, 'Avg. position')

        self.cursor.execute(
            f'''
            SELECT *
            FROM word_bigrams
            WHERE quantity >= {self.min_quantity[3]}
            ORDER BY quantity DESC, first_word ASC, second_word ASC
            {f'LIMIT {self.limits[3]}' if self.limits[3] else ''};
            '''
        )
        for row, bigr in enumerate(self.cursor.fetchall(), 1):
            word_bigrams_top.write(row, 0, bigr[0])
            word_bigrams_top.write(row, 1, bigr[1])
            word_bigrams_top.write(row, 2, bigr[2])
            word_bigrams_top.write(row, 3, bigr[2] / all_sum)
            if position:
                word_bigrams_top.write(row, 4, bigr[3])

    def sheet_en_symb_bigrams(self):
        '''Create two-dimensional bigrams table only for English alphabet symbols.

        !This function is not called from main "treat()"!
        '''
        en_symb_bigrams = self.workbook.add_worksheet('English letter bigrams')
        locations: dict = {
            **{x: n for n, x in enumerate(range(65, 91))},
            **{x: n for n, x in enumerate(range(97, 123))},
        }

        self.cursor.execute(
            '''
            SELECT *
            FROM symbol_bigrams
            WHERE (first_symb BETWEEN 65 AND 90 OR first_symb BETWEEN 97 AND 122)
                AND (second_symb BETWEEN 65 AND 90 OR second_symb BETWEEN 97 AND 122);
            '''
        )

        values: list = [[]]
        for pair in self.cursor.fetchall():
            loc_1 = locations[pair[1]]
            loc_2 = locations[pair[2]]
            while len(values) <= loc_1:
                values.append([])
            while len(values[loc_1]) <= loc_2:
                values[loc_1].append(0)
            values[loc_1][loc_2] += pair[3]

        for n, let in enumerate(ascii_lowercase, 1):
            en_symb_bigrams.write(0, n, let)
            en_symb_bigrams.write(n, 0, let)

        for row, row_list in enumerate(values, 1):
            for col, col_value in enumerate(row_list, 1):
                en_symb_bigrams.write(row, col, col_value)

    def sheet_ru_symb_bigrams(self):
        '''Create two-dimensional bigrams table only for Russian alphabet symbols.

        !This function is not called from main "treat()"!
        '''
        ru_symb_bigrams = self.workbook.add_worksheet('Russian letter bigrams')
        locations: dict = {
            **{x: n for n, x in enumerate(range(1040, 1046), 0)},
            **{x: n for n, x in enumerate(range(1072, 1078), 0)},
            **{x: n for n, x in enumerate(range(1046, 1072), 7)},
            **{x: n for n, x in enumerate(range(1078, 1104), 7)},
            **{1025: 6, 1105: 6},
        }

        self.cursor.execute(
            '''
            SELECT *
            FROM symbol_bigrams
            WHERE (first_symb BETWEEN 1040 AND 1105 OR first_symb = 1025)
                AND (second_symb BETWEEN 1040 AND 1105 OR second_symb = 1025);
            '''
        )

        values: list = [[]]
        for pair in self.cursor.fetchall():
            loc_1 = locations[pair[1]]
            loc_2 = locations[pair[2]]
            while len(values) <= loc_1:
                values.append([])
            while len(values[loc_1]) <= loc_2:
                values[loc_1].append(0)
            values[loc_1][loc_2] += pair[3]

        rus_let = 'абвгдеёжзийклмнопрстуфхцчшщьыъэюя'
        for n, let in enumerate(rus_let, 1):
            ru_symb_bigrams.write(0, n, let)
            ru_symb_bigrams.write(n, 0, let)

        for row, row_list in enumerate(values, 1):
            for col, col_value in enumerate(row_list, 1):
                ru_symb_bigrams.write(row, col, col_value)

    def sheet_yo_words(self):
        '''Create sheet with quantity of entries for both of ye/yo word writing.

        !This function is not called from main "treat()"!
        '''
        yo_words = self.workbook.add_worksheet('Ye/yo words')
        yo_words.write(0, 0, 'Yo word')
        yo_words.write(0, 1, 'Ye word')
        yo_words.write(0, 2, 'Yo mandatory?')
        yo_words.write(0, 3, 'Yo count')
        yo_words.write(0, 4, 'Ye count')

        self.cursor.execute(
            '''
            SELECT
                yo_word, ye_word, mandatory,
                word.quantity as yo_quantity,
                word.quantity as ye_quantity,
                SUM(yo_quantity, ye_quantity) as sum
            FROM yo_words
                INNER JOIN words ON yo_words.yo_word = words.word
                INNER JOIN words ON yo_words.ye_word = words.word
            ORDER BY sum;
            '''
        )

        for row, pair in enumerate(self.cursor.fetchall(), 1):
            yo_words.write(row, 0, pair[0])
            yo_words.write(row, 1, pair[1])
            yo_words.write(row, 2, ('Mandatory' if pair[2] else 'Probably'))
            self.cursor.execute(f'SELECT quantity FROM words WHERE word={pair[0]};')
            yo_words.write(row, 3, self.cursor.fetchone()[0])
            self.cursor.execute(f'SELECT quantity FROM words WHERE word={pair[1]};')
            yo_words.write(row, 4, self.cursor.fetchone()[0])
